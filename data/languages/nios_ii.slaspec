# Altera Nios II SLEIGH specs

define endian=little;

define space register type=register_space size=4

# TODO: define instruction-aligment instruction addresses must be word-aligned."
# TODO: define ram space as DEFAULT

# General-purpose registers (r0 to r31)
define register offset=0 size=4 [
	zero  r1  r2  r3  r4  r5  r6      r7
	r8    r9  r10 r11 r12 r13 r14     r15
	r16   r17 r18 r19 r20 r21 r22     r23
	et    bt  gp  sp  fp  ea  sstatus ra
];

# Control registers (Reserved registers are marked as ctlX)
define register offset=32 size=4 [
	status  estatus bstatus ienable ipending cpuid  ctl6    exception
	pteaddr tlbacc  tlbmisc eccinj  badaddr  config mpubase mpuacc
	ctl16   ctl17   ctl18   ctl19   ctl20    ctl21  ctl22   ctl23
	ctl24   ctl25   ctl26   ctl27   ctl28    ctl29  ctl30   ctl31
];
# TODO?: define status, estatus, bstatus, ienable, ipending, exception, pteaddr, tlbacc, tlbmisc, config, mpubase, mpuacc and eccinj as bitranges

# Bit fields for the 3 instruction types
define token instr (32)
	opcode = (0, 5)
# I-type specific
	imm16 = (6, 21) signed
	imm16_u = (6, 21)
	regB = (22, 26)
	regA = (27, 31)
	regB_s = (22, 26) signed
	regA_s = (27, 31) signed
# R-type specific
	opx_full = (6, 16)
	opx = (11, 16)
	regC = (17, 21)
	ctlN = (6, 10)
	imm5 = (6, 10)
# J-type specific
	imm26 = (6, 31)
# Custom instruction specific
	customN = (6, 13)
	writerC = (14, 14)
	readrB = (15, 15)
	readrC = (16, 16)
;

# Bind register fields to actual registers
attach variables [regC regB regA] [
	zero  r1  r2  r3  r4  r5  r6      r7
	r8    r9  r10 r11 r12 r13 r14     r15
	r16   r17 r18 r19 r20 r21 r22     r23
	et    bt  gp  sp  fp  ea  sstatus ra
];

attach variables [ctlN] [
	status  estatus bstatus ienable ipending cpuid  ctl6    exception
	pteaddr tlbacc  tlbmisc eccinj  badaddr  config mpubase mpuacc
	ctl16   ctl17   ctl18   ctl19   ctl20    ctl21  ctl22   ctl23
	ctl24   ctl25   ctl26   ctl27   ctl28    ctl29  ctl30   ctl31
];

# Opcodes
## J-type (opcode == 0)
:call imm26 is opcode=0x00 & imm26 {
	ra=inst_next;
	# TODO: save caller-saved registers
	call (imm26 * 4);
}
:jmpi imm26 is opcode=0x01 & imm26 {
	goto (imm26 * 4)
}

## R-type (opcode == 0x3a) sorted by OPX value
with : opcode=0x3a {
	:eret is opx=0x01 {
		status = estatus;
		goto ea;
	}
	:roli regC, regA, imm5 is opx=0x02 {
		#TODO: implement ROLI
	}
	:rol regC, regA, regB is opx=0x03 {
		#TODO: implement ROL
	}
	:flushp is opx=0x04 {} # flush prefetched instruction
	:nor regC, regA, regB is opx=0x06 {
		regC = ~(regA | regB);
	}
	:ret is opx=0x05 {
		goto ra;
	}
	:mulxuu regC, regA, regB is opx=0x07 {
		regC = (regA * regB)[63, 32];
	}
	:cmpge regC, regA_s, regB_s is opx=0x08 {
		regC = (regA_s >= regB_s);
	}
	:bret is opx=0x09 {
		unimp; # used to return from debugger
	}
	:ror regC, regA, regB is opx=0x0b {
		#TODO: implement ROR
	}
	:flushi regA is opx=0x0c {} # flush instruction cache
	:jmp regA is opx=0x0d {
		goto regA;
	}
	:and regC, regA, regB is opx=0x0e {
		regC = regA & regB;
	}
	:cmplt regC, regA_s, regB_s is opx=0x10 {
		regC = (regA_s < regB_s);
	}
	:slli regC, regA, imm5 is opx=0x12 {
		regC = regA << imm5;
	}
	:sll regC, regA, regB is opx=0x13 {
		regC = regA << (regB[4, 0]);
	}
	:wrprs regC, regA is opx=0x14 {
		unimp; # Copies the value of regA in the current register set to regC in the previous register set.
	}
	:or regC, regA, regB is opx=0x16 {
		regC = regA | regB;
	}
	:mulxsu regC, regA_s, regB is opx=0x17 {
		regC = (regA_s * regB)[63, 32];
	}
	:cmpne regC, regA, regB is opx=0x18 {
		regC = (regA != regB);
	}
	:srli regC, regA, imm5 is opx=0x1a {
		regC = regA << imm5;
	}
	:srl regC, regA, regB is opx=0x1b {
		regC = regA << (regB[4, 0]);
	}
	:nextpc regC is opx=0x1c {
		regC = next_inst;
	}
	:callr regA is opx=0x1d {
		ra = next_inst;
		# TODO: save caller-saved registers
		call regA;
	}
	:xor regC, regA, regB is opx=0x1e {
		regC = (regA ^ regB);
	}
	:mulxss regC, regA_s, regB_s is opx=0x1f {
		regC = (regA_s * regB_s)[63, 32];
	}
	:cmpeq regC, regA, regB is opx=0x20 {
		regC = (regB == regA);
	}
	:divu regC, regA, regB is opx=0x24 {
		regC = regA / regB;
	}
	:div regC, regA_s, regB_s is opx=0x25 {
		regC = regA_s s/ regB_s;
	}
	:rdctl regC, ctlN is opx=0x26 {
		regC = ctlN;
	}
	:mul regC, regA, regB is opx=0x27 {
		regC = regA * regB;
	}
	:cmpgeu regC, regA, regB is opx=0x28 {
		regC = (regA >= regB);
	}
	:initi regA is {} # initialize instruction cache
	:trap imm5 is opx=0x2d {
		unimp; # used to go to exception handler
	}
	:wrctl ctlN, regA is opx=0x2e {
		ctlN = regA;
	}
	:cmpltu regC, regA, regB is opx=0x30 {
		regC = (regA < regB);
	}
	with : opx=0x31
		:add regC, regA, regB is regC!=zero & regB!=zero {
			regC = regA + regB; #TODO: handle overflow
		}
		:mov regC, regA is regB=zero & regC !=zero {
			regC = regA;
		}
		:nop is regC=zero {}
	}
	:break is opx=0x34 {
		unimp; # used to go to debugger
	}
	:sync is opx=0x36 {} # Forces all pending memory accesses to complete before continuing
	:sub regR, regA, regB is opx=0x39 {
		regC = regA - regB;
	}
	:srai regC, regA_s, imm5 is opx=0x3a {
		regC = regA >> imm5;
	}
	:sra regC, regA_s, regB is opx=0x3b {
		regC = regA >> (regB[4, 0]);
	}
}

### Custom instructions
with : opcode=0x32 {
	:custom customN, regC, regA, regB is {
		unimp;
	}
}

## I-type
:ldbu regB, imm16(^regA^) is opcode=0x03 {
	regB = *:1 regA;
}
:addi regB, regA, imm16 is opcode=0x04 {
	regB = regA + imm16
}
:stb regB. imm16(^regA^) is opcode=0x05 {
	*:1 (regA + imm16) = regB[7, 0];
}
:br imm16 is opcode=0x06 {
	goto (next_inst + imm16);
}
:ldb regB_s, imm16(^regA^) is opcode=0x07 {
	regB_s = *:1 regA;
}
:cmpgei regB, regA_s, imm16 is ocpode=0x08 {
	regB = (regA_s >= imm16);
}
:ldhu regB, imm16(^regA^) is opcode=0x0b {
	regB = *:2 regA;
}
:andi regB, regA, imm16 is opcode=0x0c {
	regB = regA & imm16;
}
:sth regB. imm16(^regA^) is opcode=0x0d {
	*:2 (regA + imm16) = regB[15, 0];
}
:bge regA_s, regB_s, imm16 is opcode=0x0e {
	if (regA_s >= regB_s) goto (next_inst + imm16);
}
:ldh regB_s, imm16(^regA^) is opcode=0x0f {
	regB_s = *:2 regA;
}
:cmplti regB, regA_s, imm16 is ocpode=0x10 {
	regB = (regA_s < imm16);
}
:initda imm16(^regA^) {} # Initializes the data cache line currently caching address rA + σ(IMM16)
:ori regB, regA, imm16 is opcode=0x14 {
	regB = regA | imm16;
}
:stw regB. imm16(^regA^) is opcode=0x15 {
	*:4 (regA + imm16) = regB;
}
:blt regA_s, regB_s, imm16 is opcode=0x16 {
	if (regA_s < regB_s) goto (next_inst + imm16);
}
:ldw regB, imm16(^regA^) is opcode=0x17 {
	regB = *:4 regA;
}
:cmpnei regB, regA, imm16 is opcode=0x18 {
	regB = (regA != imm16);
}
:flushda imm16(^regA^) is opcode=0x1b {} # Flushes the data cache line currently caching address rA + σ(IMM16).
:xori regB, regA, imm16 is opcode=0x1c {
	regB = regA ^ imm16;
}
:bne regA, regB, imm16 is opcode=0x1e {
	if (regA != regB) goto (next_inst + imm16);
}
:cmpeqi regB, regA, imm16 is opcode=0x20 {
	regB = (regA == imm16);
}
:ldbuio regB, imm16(^regA^) is opcode=0x23 {
	regB = *:1 regA;
}
:muli regB, regA, imm16 is ocpode=0x24 {
	regB = regA * imm16;
}
:stbio regB. imm16(^regA^) is opcode=0x25 {
	*:1 (regA + imm16) = regB[7, 0];
}
:beq regA, regB, imm16 is opcode=0x26 {
	if (regA == regB) goto (next_inst + imm16);
}
:ldbio regB_s, imm16(^regA^) is opcode=0x27 {
	regB_s = *:1 regA;
}
:cmpgeui regB, regA, imm16_u is ocpode=0x28 {
	regB = (regA >= imm16_u);
}
:ldhuio regB, imm16(^regA^) is opcode=0x2b {
	regB = *:2 regA;
}
:andhi regB, regA, imm16 is opcode=0x2c {
	regB = regA & (imm16 << 16);
}
:sthio regB. imm16(^regA^) is opcode=0x2d {
	*:2 (regA + imm16) = regB[15, 0];
}
:bgeu regA, regB, imm16 is opcode=0x2e {
	if (regA >= regB) goto (next_inst + imm16);
}
:ldhio regB_s, imm16(^regA^) is opcode=0x2f {
	regB_s = *:2 regA;
}
:cmpltui regB, regA, imm16_u is ocpode=0x30 {
	regB = (regA < imm16_u);
}
:initd imm16(^regA^) is opcode=0x33 {} # Initializes the data cache line associated with address rA + σ(IMM16).
:orhi regB, regA, imm16 is opcode=0x34 {
	regB = regA | (imm16 << 16);
}
:stwio regB. imm16(^regA^) is opcode=0x35 {
	*:4 (regA + imm16) = regB;
}
:bltu regA, regB, imm16 is opcode=0x36 {
	if (regA < regB) goto (next_inst + imm16);
}
:ldwio regB, imm16(^regA^) is opcode=0x37 {
	regB = *:4 regA;
}
:rdprs regB, regA, imm16 {
	unimp; # Read from the previous register set.
}
:flushd imm16(^regA^) is opcode=0x3b {} # Flushes the data cache line associated with address rA + σ(IMM16).
:xorhi regB, regA, imm16 is opcode=0x3c {
	regB = regA ^ (imm16 << 16);
}
