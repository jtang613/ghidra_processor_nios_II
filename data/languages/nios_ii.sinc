@define REG_SIZE 32
# Opcodes
## J-type (opcode == 0)
:call imm26 is opcode=0x00 & imm26 {
	ra = inst_next;
	# TODO: save caller-saved registers
	local fct:4 = imm26 * 4;
	call [fct];
}
:jmpi imm26 is opcode=0x01 & imm26 {
	local dest:4 = imm26 * 4;
	goto [dest];
}

## R-type (opcode == 0x3a) sorted by OPX value
with : opcode=0x3a {
	:eret is opx=0x01 {
		status = estatus;
		return [ea];
	}
	:roli regC, regA, imm5 is opx=0x02 {
		local roll = imm5 % $(REG_SIZE);
		regC = (regA << roll) | (regA >> ($(REG_SIZE) - roll));
	}
	:rol regC, regA, regB is opx=0x03 {
		local roll = regB[4, 5];
		regC = (regA << roll) | (regA >> ($(REG_SIZE) - roll));
	}
	:flushp is opx=0x04 {} # flush prefetched instruction
	:nor regC, regA, regB is opx=0x06 {
		regC = ~(regA | regB);
	}
	:ret is opx=0x05 {
		return [ra];
	}
	:mulxuu regC, regA, regB is opx=0x07 {
		regC = (regA * regB) >> 32;
	}
	:cmpge regC, regA_s, regB_s is opx=0x08 {
		regC = zext(regA_s s>= regB_s);
	}
	:bret is opx=0x09 unimpl # used to return from debugger
	:ror regC, regA, regB is opx=0x0b {
		local roll = regB[4, 5];
		regC = (regA >> roll) | (regA << ($(REG_SIZE) - roll));
	}
	:flushi regA is opx=0x0c {} # flush instruction cache
	:jmp regA is opx=0x0d {
		goto regA;
	}
	:and regC, regA, regB is opx=0x0e {
		regC = regA & regB;
	}
	:cmplt regC, regA_s, regB_s is opx=0x10 {
		regC = zext(regA_s s< regB_s);
	}
	:slli regC, regA, imm5 is opx=0x12 {
		regC = regA << imm5;
	}
	:sll regC, regA, regB is opx=0x13 {
		regC = regA << (regB[4, 4]);
	}
	:wrprs regC, regA is opx=0x14 unimpl # Copies the value of regA in the current register set to regC in the previous register set.
	:or regC, regA, regB is opx=0x16 {
		regC = regA | regB;
	}
	:mulxsu regC, regA_s, regB is opx=0x17 {
		regC = (regA_s * regB) >> 32;
	}
	:cmpne regC, regA, regB is opx=0x18 {
		regC = zext(regA != regB);
	}
	:srli regC, regA, imm5 is opx=0x1a {
		regC = regA >> imm5;
	}
	:srl regC, regA, regB is opx=0x1b {
		regC = regA >> (regB[4, 4]);
	}
	:nextpc regC is opx=0x1c {
		regC = inst_next;
	}
	:callr regA is opx=0x1d {
		ra = inst_next;
		# TODO: save caller-saved registers
		call regA;
	}
	:xor regC, regA, regB is opx=0x1e {
		regC = (regA ^ regB);
	}
	:mulxss regC, regA_s, regB_s is opx=0x1f {
		regC = (regA_s * regB_s) >> 32;
	}
	:cmpeq regC, regA, regB is opx=0x20 {
		regC = zext(regB == regA);
	}
	:divu regC, regA, regB is opx=0x24 {
		regC = regA / regB;
	}
	:div regC, regA_s, regB_s is opx=0x25 {
		regC = regA_s s/ regB_s;
	}
	:rdctl regC, ctlN is opx=0x26 {
		regC = ctlN;
	}
	:mul regC, regA, regB is opx=0x27 {
		regC = regA * regB;
	}
	:cmpgeu regC, regA, regB is opx=0x28 {
		regC = zext(regA >= regB);
	}
	:initi regA is opx=29 {} # initialize instruction cache
	:trap imm5 is opx=0x2d unimpl # used to go to exception handler
	:wrctl ctlN, regA is opx=0x2e {
		ctlN = regA;
	}
	:cmpltu regC, regA, regB is opx=0x30 {
		regC = zext(regA < regB);
	}
	with : opx=0x31 {
		:add regC, regA, regB is opx=0x31 {
			regC = regA + regB; #TODO: handle overflow
		}
		#:mov regC, regA is regB=0 & regC !=0 {
		#	regC = regA;
		#}
		#:nop is regC=zero {}
	}
	:break is opx=0x34 unimpl # used to go to debugger
	:sync is opx=0x36 {} # Forces all pending memory accesses to complete before continuing
	:sub regC, regA, regB is opx=0x39 {
		regC = regA - regB;
	}
	:srai regC_s, regA_s, imm5 is opx=0x3a {
		regC_s = regA_s s>> imm5;
	}
	:sra regC, regA_s, regB is opx=0x3b {
		regC = regA_s s>> (regB[4, 4]);
	}
}

### Custom instructions
:custom customN, regC, regA, regB is opcode=0x32 unimpl

## I-type
:ldbu regB, imm16(^regA^) is opcode=0x03 {
	regB = zext(*:1 (regA + sext(imm16)));
}
:addi regB, regA, imm16 is opcode=0x04 {
	regB = regA + sext(imm16);
}
:stb regB, imm16(^regA^) is opcode=0x05 {
	*:1 (regA + sext(imm16)) = regB[7, 8];
}
:br imm16 is opcode=0x06 {
	local dest:4 = inst_next + sext(imm16);
	goto [dest];
}
:ldb regB_s, imm16(^regA^) is opcode=0x07 {
	regB_s = sext(*:1 (regA + sext(imm16)));
}
:cmpgei regB, regA_s, imm16 is opcode=0x08 {
	regB = zext(regA_s s>= sext(imm16));
}
:ldhu regB, imm16(^regA^) is opcode=0x0b {
	regB = zext(*:2 (regA + sext(imm16)));
}
:andi regB, regA, imm16 is opcode=0x0c {
	regB = regA & zext(imm16);
}
:sth regB, imm16(^regA^) is opcode=0x0d {
	*:2 (regA + sext(imm16)) = regB[15, 16];
}
:bge regA_s, regB_s, imm16 is opcode=0x0e {
	local dest:4 = inst_next + sext(imm16);
	if (regA_s s>= regB_s) goto <end>;
		 goto [dest];
	<end>
}
:ldh regB_s, imm16(^regA^) is opcode=0x0f {
	regB_s = sext(*:2 (regA + sext(imm16)));
}
:cmplti regB, regA_s, imm16 is opcode=0x10 {
	regB = zext(regA_s s< sext(imm16));
}
:initda imm16(^regA^) is opcode=0x13 {} # Initializes the data cache line currently caching address rA + sext(IMM16)
:ori regB, regA, imm16 is opcode=0x14 {
	regB = regA | zext(imm16);
}
:stw regB, imm16(^regA^) is opcode=0x15 {
	*:4 (regA + sext(imm16)) = regB;
}
:blt regA_s, regB_s, imm16 is opcode=0x16 {
	local dest:4 = inst_next + sext(imm16);
	if (regA_s s< regB_s) goto <end>;
		goto [dest];
	<end>
}
:ldw regB, imm16(^regA^) is opcode=0x17 {
	regB = *:4 (regA + sext(imm16));
}
:cmpnei regB, regA, imm16 is opcode=0x18 {
	regB = zext(regA != sext(imm16));
}
:flushda imm16(^regA^) is opcode=0x1b {} # Flushes the data cache line currently caching address rA + sext(IMM16).
:xori regB, regA, imm16 is opcode=0x1c {
	regB = regA ^ zext(imm16);
}
:bne regA, regB, imm16 is opcode=0x1e {
	local dest:4 = inst_next + sext(imm16);
	if (regA != regB) goto <end>;
		goto [dest];
	<end>
}
:cmpeqi regB, regA, imm16 is opcode=0x20 {
	regB = zext(regA == sext(imm16));
}
:ldbuio regB, imm16(^regA^) is opcode=0x23 {
	regB = zext(*:1 (regA + sext(imm16)));
}
:muli regB, regA, imm16 is opcode=0x24 {
	regB = regA * zext(imm16);
}
:stbio regB, imm16(^regA^) is opcode=0x25 {
	*:1 (regA + sext(imm16)) = regB[7, 8];
}
:beq regA, regB, imm16 is opcode=0x26 {
	local dest:4 = inst_next + sext(imm16);
	if (regA == regB) goto <end>;
		goto [dest];
	<end>
}
:ldbio regB_s, imm16(^regA^) is opcode=0x27 {
	regB_s = sext(*:1 (regA + sext(imm16)));
}
:cmpgeui regB, regA, imm16_u is opcode=0x28 {
	regB = zext(regA >= zext(imm16_u));
}
:ldhuio regB, imm16(^regA^) is opcode=0x2b {
	regB = zext(*:2 (regA + sext(imm16)));
}
:andhi regB, regA, imm16 is opcode=0x2c {
	regB = regA & (imm16 << 16);
}
:sthio regB, imm16(^regA^) is opcode=0x2d {
	local location = regA + sext(imm16);
	*:2	location  = regB[15, 16];
}
:bgeu regA, regB, imm16 is opcode=0x2e {
	local dest:4 = inst_next + sext(imm16);
	if (regA >= regB) goto <end>;
		goto [dest];
	<end>
}
:ldhio regB_s, imm16(^regA^) is opcode=0x2f {
	regB_s = sext(*:2 (regA + sext(imm16)));
}
:cmpltui regB, regA, imm16_u is opcode=0x30 {
	regB = zext(regA < zext(imm16_u));
}
:initd imm16(^regA^) is opcode=0x33 {} # Initializes the data cache line associated with address rA + sext(IMM16).
:orhi regB, regA, imm16 is opcode=0x34 {
	regB = regA | (imm16 << 16);
}
:stwio regB, imm16(^regA^) is opcode=0x35 {
	*:4 (regA + sext(imm16)) = regB;
}
:bltu regA, regB, imm16 is opcode=0x36 {
	local dest:4 = inst_next + sext(imm16);
	if (regA < regB) goto <end>;
		goto [dest];
	<end>
}
:ldwio regB, imm16(^regA^) is opcode=0x37 {
	regB = *:4 (regA + sext(imm16));
}
:rdprs regB, regA, imm16 is opcode=0x38 unimpl # Read from the previous register set.
:flushd imm16(^regA^) is opcode=0x3b {} # Flushes the data cache line associated with address rA + sext(IMM16).
:xorhi regB, regA, imm16 is opcode=0x3c {
	regB = regA ^ (imm16 << 16);
}
