@define REG_SIZE 32
# Opcodes
## J-type (opcode == 0)
:call immed26 is opcode=0x00 & immed26 {
	ra = inst_next;
	# TODO: save caller-saved registers
	local fct:4 = (inst_start & 0b00000000000000000000000000001111) | zext(immed26) * 4;
	call [fct];
}
:jmpi immed26 is opcode=0x01 & immed26 {
	local dest:4 = zext(immed26) * 4;
	goto [dest];
}

## R-type (opcode == 0x3a) sorted by OPX value
with : opcode=0x3a {
	:eret is opx=0x01 {
		status = estatus;
		return [ea];
	}
	:roli regC, regA, immed5 is opx=0x02 & regC & regA & immed5 {
		local roll = immed5 % $(REG_SIZE);
		regC = (regA << roll) | (regA >> ($(REG_SIZE) - roll));
	}
	:rol regC, regA, regB is opx=0x03 & regA & regB & regC {
		local roll = regB[4, 5];
		regC = (regA << roll) | (regA >> ($(REG_SIZE) - roll));
	}
	:flushp is opx=0x04 {} # flush prefetched instruction
	:nor regC, regA, regB is opx=0x06 & regA & regB & regC {
		regC = ~(regA | regB);
	}
	:ret is opx=0x05 {
		return [ra];
	}
	:mulxuu regC, regA, regB is opx=0x07 & regA & regB & regC {
		regC = (regA * regB) >> 32;
	}
	:cmpge regC, regA_s, regB_s is opx=0x08 & regA_s & regB_s & regC {
		regC = zext(regA_s s>= regB_s);
	}
	:bret is opx=0x09 unimpl # used to return from debugger
	:ror regC, regA, regB is opx=0x0b & regA & regB & regC {
		local roll = regB[4, 5];
		regC = (regA >> roll) | (regA << ($(REG_SIZE) - roll));
	}
	:flushi regA is opx=0x0c & regA {} # flush instruction cache
	:jmp regA is opx=0x0d & regA {
		goto regA;
	}
	:and regC, regA, regB is opx=0x0e & regA & regB & regC {
		regC = regA & regB;
	}
	:cmplt regC, regA_s, regB_s is opx=0x10 & regC & regB_s & regA_s {
		regC = zext(regA_s s< regB_s);
	}
	:slli regC, regA, immed5 is opx=0x12 & regA & regC & immed5 {
		regC = regA << immed5;
	}
	:sll regC, regA, regB is opx=0x13 & regA & regB & regC {
		regC = regA << (regB[4, 4]);
	}
	:wrprs regC, regA is opx=0x14 & regC & regA unimpl # Copies the value of regA in the current register set to regC in the previous register set.
	:or regC, regA, regB is opx=0x16 & regA & regB & regC {
		regC = regA | regB;
	}
	:mulxsu regC, regA_s, regB is opx=0x17 & regC & regB & regA_s {
		regC = (regA_s * regB) >> 32;
	}
	:cmpne regC, regA, regB is opx=0x18 & regA & regB & regC {
		regC = zext(regA != regB);
	}
	:srli regC, regA, immed5 is opx=0x1a & regA & regC & immed5 {
		regC = regA >> immed5;
	}
	:srl regC, regA, regB is opx=0x1b & regA & regB & regC {
		regC = regA >> (regB[4, 4]);
	}
	:nextpc regC is opx=0x1c & regC {
		regC = inst_next;
	}
	:callr regA is opx=0x1d & regA {
		ra = inst_next;
		# TODO: save caller-saved registers
		call regA;
	}
	:xor regC, regA, regB is opx=0x1e & regA & regB & regC {
		regC = (regA ^ regB);
	}
	:mulxss regC, regA_s, regB_s is opx=0x1f & regC & regB_s & regA_s {
		regC = (regA_s * regB_s) >> 32;
	}
	:cmpeq regC, regA, regB is opx=0x20 & regA & regB & regC {
		regC = zext(regB == regA);
	}
	:divu regC, regA, regB is opx=0x24 & regA & regB & regC {
		regC = regA / regB;
	}
	:div regC, regA_s, regB_s is opx=0x25 & regC & regB_s & regA_s {
		regC = regA_s s/ regB_s;
	}
	:rdctl regC, ctlN is opx=0x26 & regC & ctlN {
		regC = ctlN;
	}
	:mul regC, regA, regB is opx=0x27 & regA & regB & regC {
		regC = regA * regB;
	}
	:cmpgeu regC, regA, regB is opx=0x28 & regA & regB & regC {
		regC = zext(regA >= regB);
	}
	:initi regA is opx=0x29 & regA {} # initialize instruction cache
	:trap immed5 is opx=0x2d & immed5 unimpl # used to go to exception handler
	:wrctl ctlN, regA is opx=0x2e & ctlN & regA {
		ctlN = regA;
	}
	:cmpltu regC, regA, regB is opx=0x30 & regA & regB & regC {
		regC = zext(regA < regB);
	}
	with : opx=0x31 {
		:add regC, regA, regB is opx=0x31 & regA & regB & regC {
			regC = regA + regB; #TODO: handle overflow
		}
		#:mov regC, regA is regB=0 & regC !=0 {
		#	regC = regA;
		#}
		#:nop is regC=zero {}
	}
	:break is opx=0x34 unimpl # used to go to debugger
	:sync is opx=0x36 {} # Forces all pending memory accesses to complete before continuing
	:sub regC, regA, regB is opx=0x39 & regA & regB & regC {
		regC = regA - regB;
	}
	:srai regC_s, regA_s, immed5 is opx=0x3a & regC_s & regA_s & immed5 {
		regC_s = regA_s s>> immed5;
	}
	:sra regC, regA_s, regB is opx=0x3b & regC & regB & regA_s {
		regC = regA_s s>> (regB[4, 4]);
	}
}

### Custom instructions
:custom customN, regC, regA, regB is opcode=0x32 & customN & regC & regB & regA unimpl

## I-type
:ldbu regB, immed16(^regA^) is opcode=0x03 & immed16 & regA & regB {
	regB = zext(*:1 (regA + sext(immed16)));
}
:addi regB, regA, immed16 is opcode=0x04 & immed16 & regA & regB {
	regB = regA + sext(immed16);
}
:stb regB, immed16(^regA^) is opcode=0x05 & immed16 & regA & regB {
	*:1 (regA + sext(immed16)) = regB[7, 8];
}
:br immed16 is opcode=0x06 & immed16 {
	local dest:4 = inst_next + sext(immed16);
	goto [dest];
}
:ldb regB_s, immed16(^regA^) is opcode=0x07 & immed16 & regB_s & regA {
	regB_s = sext(*:1 (regA + sext(immed16)));
}
:cmpgei regB, regA_s, immed16 is opcode=0x08 & immed16 & regA_s & regB {
	regB = zext(regA_s s>= sext(immed16));
}
:ldhu regB, immed16(^regA^) is opcode=0x0b & immed16 & regA & regB {
	regB = zext(*:2 (regA + sext(immed16)));
}
:andi regB, regA, immed16 is opcode=0x0c & immed16 & regA & regB {
	regB = regA & zext(immed16);
}
:sth regB, immed16(^regA^) is opcode=0x0d & immed16 & regA & regB {
	*:2 (regA + sext(immed16)) = regB[15, 16];
}
:bge regA_s, regB_s, immed16 is opcode=0x0e & immed16 & regB_s & regA_s {
	local dest:4 = inst_next + sext(immed16);
	if (regA_s s>= regB_s) goto <end>;
		 goto [dest];
	<end>
}
:ldh regB_s, immed16(^regA^) is opcode=0x0f & immed16 & regB_s & regA {
	regB_s = sext(*:2 (regA + sext(immed16)));
}
:cmplti regB, regA_s, immed16 is opcode=0x10 & immed16 & regA_s & regB {
	regB = zext(regA_s s< sext(immed16));
}
:initda immed16(^regA^) is opcode=0x13 & immed16 & regA {} # Initializes the data cache line currently caching address rA + sext(IMM16)
:ori regB, regA, immed16 is opcode=0x14 & immed16 & regA & regB {
	regB = regA | zext(immed16);
}
:stw regB, immed16(^regA^) is opcode=0x15 & immed16 & regA & regB {
	*:4 (regA + sext(immed16)) = regB;
}
:blt regA_s, regB_s, immed16 is opcode=0x16 & immed16 & regB_s & regA_s {
	local dest:4 = inst_next + sext(immed16);
	if (regA_s s< regB_s) goto <end>;
		goto [dest];
	<end>
}
:ldw regB, immed16(^regA^) is opcode=0x17 & immed16 & regA & regB {
	regB = *:4 (regA + sext(immed16));
}
:cmpnei regB, regA, immed16 is opcode=0x18 & immed16 & regA & regB {
	regB = zext(regA != sext(immed16));
}
:flushda immed16(^regA^) is opcode=0x1b & immed16 & regA {} # Flushes the data cache line currently caching address rA + sext(IMM16).
:xori regB, regA, immed16 is opcode=0x1c & immed16 & regA & regB {
	regB = regA ^ zext(immed16);
}
:bne regA, regB, immed16 is opcode=0x1e & immed16 & regA & regB {
	local dest:4 = inst_next + sext(immed16);
	if (regA != regB) goto <end>;
		goto [dest];
	<end>
}
:cmpeqi regB, regA, immed16 is opcode=0x20 & immed16 & regA & regB {
	regB = zext(regA == sext(immed16));
}
:ldbuio regB, immed16(^regA^) is opcode=0x23 & immed16 & regA & regB {
	regB = zext(*:1 (regA + sext(immed16)));
}
:muli regB, regA, immed16 is opcode=0x24 & immed16 & regA & regB {
	regB = regA * zext(immed16);
}
:stbio regB, immed16(^regA^) is opcode=0x25 & immed16 & regA & regB {
	*:1 (regA + sext(immed16)) = regB[7, 8];
}
:beq regA, regB, immed16 is opcode=0x26 & immed16 & regA & regB {
	local dest:4 = inst_next + sext(immed16);
	if (regA == regB) goto <end>;
		goto [dest];
	<end>
}
:ldbio regB_s, immed16(^regA^) is opcode=0x27 & immed16 & regB_s & regA {
	regB_s = sext(*:1 (regA + sext(immed16)));
}
:cmpgeui regB, regA, immed16_u is opcode=0x28 & immed16_u & regA & regB {
	regB = zext(regA >= zext(immed16_u));
}
:ldhuio regB, immed16(^regA^) is opcode=0x2b & immed16 & regA & regB {
	regB = zext(*:2 (regA + sext(immed16)));
}
:andhi regB, regA, immed16 is opcode=0x2c & immed16 & regA & regB {
	regB = regA & (zext(immed16) << 16);
}
:sthio regB, immed16(^regA^) is opcode=0x2d & immed16 & regA & regB {
	local location = regA + sext(immed16);
	*:2	location  = regB[15, 16];
}
:bgeu regA, regB, immed16 is opcode=0x2e & immed16 & regA & regB {
	local dest:4 = inst_next + sext(immed16);
	if (regA >= regB) goto <end>;
		goto [dest];
	<end>
}
:ldhio regB_s, immed16(^regA^) is opcode=0x2f & immed16 & regB_s & regA {
	regB_s = sext(*:2 (regA + sext(immed16)));
}
:cmpltui regB, regA, immed16_u is opcode=0x30 & immed16_u & regA & regB {
	regB = zext(regA < zext(immed16_u));
}
:initd immed16(^regA^) is opcode=0x33 & immed16 & regA {} # Initializes the data cache line associated with address rA + sext(IMM16).
:orhi regB, regA, immed16 is opcode=0x34 & immed16 & regA & regB {
	regB = regA | (zext(immed16) << 16);
}
:stwio regB, immed16(^regA^) is opcode=0x35 & immed16 & regA & regB {
	*:4 (regA + sext(immed16)) = regB;
}
:bltu regA, regB, immed16 is opcode=0x36 & immed16 & regA & regB {
	local dest:4 = inst_next + sext(immed16);
	if (regA < regB) goto <end>;
		goto [dest];
	<end>
}
:ldwio regB, immed16(^regA^) is opcode=0x37 & immed16 & regA & regB {
	regB = *:4 (regA + sext(immed16));
}
:rdprs regB, regA, immed16 is opcode=0x38 & regB & regA & immed16 unimpl # Read from the previous register set.
:flushd immed16(^regA^) is opcode=0x3b & immed16 & regA {} # Flushes the data cache line associated with address rA + sext(IMM16).
:xorhi regB, regA, immed16 is opcode=0x3c & immed16 & regA & regB {
	regB = regA ^ (zext(immed16) << 16);
}
